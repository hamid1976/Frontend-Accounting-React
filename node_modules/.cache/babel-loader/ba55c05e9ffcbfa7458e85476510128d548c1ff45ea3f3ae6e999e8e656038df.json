{"ast":null,"code":"// Calculate AR summary\n// export const calculateARSummary = (customers, allSalesData) => {\n//   const totalAR = customers.reduce((sum, customer) => sum + customer.totalOwed, 0);\n//   const totalOverdue = customers.reduce((sum, customer) => sum + customer.overdueAmount, 0);\n//   const customersWithBalance = customers.filter(customer => customer.totalOwed > 0).length;\n\n//   // Calculate real average days outstanding from actual order data\n//   let totalDaysOutstanding = 0;\n//   let orderCount = 0;\n\n//   if (allSalesData) {\n//     allSalesData.forEach(order => {\n//       // Convert order creation date from \"2025.08.18.10.08.54.569\" to proper date\n//       const orderDateStr = order.createdAt.split('.').slice(0, 3).join('-'); // \"2025-08-18\"\n//       const orderDate = new Date(orderDateStr);\n//       const today = new Date();\n\n//       // Calculate days between order creation and today\n//       const timeDiff = today.getTime() - orderDate.getTime();\n//       const daysDiff = Math.floor(timeDiff / (1000 * 3600 * 24));\n\n//       totalDaysOutstanding += daysDiff;\n//       orderCount++;\n//     });\n//   }\n\n//   const avgDaysOutstanding = orderCount > 0 ? Math.round(totalDaysOutstanding / orderCount) : 0;\n\n//   return {\n//     totalAR,\n//     totalOverdue,\n//     customersWithBalance,\n//     avgDaysOutstanding\n//   };\n// };\n\n// Calculate AR summary\nexport const calculateARSummary = allSalesData => {\n  let totalAR = 0;\n  let totalOverdue = 0;\n  let totalDaysOutstanding = 0;\n  let orderCount = 0;\n  const namedCustomerSet = new Set();\n  let customersWithBalance = 0;\n  if (allSalesData && Array.isArray(allSalesData)) {\n    allSalesData.forEach(order => {\n      // Only consider unpaid or partially paid orders\n      if (order['Payment Status'] !== 'Paid') {\n        var _order$Amount, _order$Customer;\n        // Clean amount string like \"$50,000.00\" → number\n        const amountStr = ((_order$Amount = order.Amount) === null || _order$Amount === void 0 ? void 0 : _order$Amount.toString()) || '0';\n        const amount = parseFloat(amountStr.replace(/[^0-9.-]+/g, \"\")) || 0;\n        totalAR += amount;\n        if (order['Payment Status'] === 'Unpaid') {\n          totalOverdue += amount;\n        }\n        const customerName = (_order$Customer = order.Customer) === null || _order$Customer === void 0 ? void 0 : _order$Customer.trim();\n        if (customerName && customerName !== 'Guest Customer') {\n          if (!namedCustomerSet.has(customerName)) {\n            namedCustomerSet.add(customerName);\n            customersWithBalance++;\n          }\n        } else {\n          // Count each unpaid guest order separately\n          customersWithBalance++;\n        }\n\n        // Parse date safely\n        const orderDate = new Date(order.Date);\n        if (!isNaN(orderDate)) {\n          const today = new Date();\n          const daysDiff = Math.floor((today.getTime() - orderDate.getTime()) / (1000 * 3600 * 24));\n          totalDaysOutstanding += daysDiff;\n          orderCount++;\n        }\n      }\n    });\n  }\n  const avgDaysOutstanding = orderCount > 0 ? Math.round(totalDaysOutstanding / orderCount) : 0;\n  return {\n    totalAR,\n    totalOverdue,\n    customersWithBalance,\n    avgDaysOutstanding\n  };\n};\n\n// Get aging data\nexport const getAgingData = salesData => {\n  const aging = {\n    current: 0,\n    days30: 0,\n    days60: 0,\n    days90: 0,\n    over90: 0\n  };\n  salesData.forEach(order => {\n    if (order.paid) return;\n    const daysPastDue = order.daysOverdue || 0;\n    if (daysPastDue <= 0) {\n      aging.current += order.total;\n    } else if (daysPastDue <= 30) {\n      aging.days30 += order.total;\n    } else if (daysPastDue <= 60) {\n      aging.days60 += order.total;\n    } else if (daysPastDue <= 90) {\n      aging.days90 += order.total;\n    } else {\n      aging.over90 += order.total;\n    }\n  });\n  return aging;\n};\n\n// Filter customers\nexport const getFilteredCustomers = (customers, filters) => {\n  // First check if we have valid data\n  if (!customers || !Array.isArray(customers)) {\n    return [];\n  }\n\n  // Start by filtering ONLY customers WITH names\n  let filtered = customers.filter(customer => customer && customer.name && typeof customer.name === 'string' && customer.name.trim() !== '');\n\n  // Now apply the rest of the filters to our name-filtered list\n  if (filters && filters.customerType && filters.customerType !== 'all') {\n    filtered = filtered.filter(customer => customer.customerType === filters.customerType);\n  }\n  if (filters && filters.status && filters.status !== 'all') {\n    filtered = filtered.filter(customer => {\n      if (filters.status === 'overdue') return customer.overdueAmount > 0;\n      if (filters.status === 'current') return customer.totalOwed > 0 && customer.overdueAmount === 0;\n      if (filters.status === 'paid_up') return customer.totalOwed === 0;\n      return true;\n    });\n  }\n  if (filters && filters.searchTerm) {\n    const term = filters.searchTerm.toLowerCase();\n    filtered = filtered.filter(customer => customer.name.toLowerCase().includes(term) || customer.email && customer.email.toLowerCase().includes(term) || customer.id && customer.id.toLowerCase().includes(term));\n  }\n  console.log(`Filtered to ${filtered.length} customers with valid names`);\n  return filtered;\n};","map":{"version":3,"names":["calculateARSummary","allSalesData","totalAR","totalOverdue","totalDaysOutstanding","orderCount","namedCustomerSet","Set","customersWithBalance","Array","isArray","forEach","order","_order$Amount","_order$Customer","amountStr","Amount","toString","amount","parseFloat","replace","customerName","Customer","trim","has","add","orderDate","Date","isNaN","today","daysDiff","Math","floor","getTime","avgDaysOutstanding","round","getAgingData","salesData","aging","current","days30","days60","days90","over90","paid","daysPastDue","daysOverdue","total","getFilteredCustomers","customers","filters","filtered","filter","customer","name","customerType","status","overdueAmount","totalOwed","searchTerm","term","toLowerCase","includes","email","id","console","log","length"],"sources":["C:/Users/Logic-Unit/my-account/src/Utility/apCalculations.js"],"sourcesContent":["// Calculate AR summary\r\n// export const calculateARSummary = (customers, allSalesData) => {\r\n//   const totalAR = customers.reduce((sum, customer) => sum + customer.totalOwed, 0);\r\n//   const totalOverdue = customers.reduce((sum, customer) => sum + customer.overdueAmount, 0);\r\n//   const customersWithBalance = customers.filter(customer => customer.totalOwed > 0).length;\r\n\r\n  \r\n//   // Calculate real average days outstanding from actual order data\r\n//   let totalDaysOutstanding = 0;\r\n//   let orderCount = 0;\r\n  \r\n//   if (allSalesData) {\r\n//     allSalesData.forEach(order => {\r\n//       // Convert order creation date from \"2025.08.18.10.08.54.569\" to proper date\r\n//       const orderDateStr = order.createdAt.split('.').slice(0, 3).join('-'); // \"2025-08-18\"\r\n//       const orderDate = new Date(orderDateStr);\r\n//       const today = new Date();\r\n      \r\n//       // Calculate days between order creation and today\r\n//       const timeDiff = today.getTime() - orderDate.getTime();\r\n//       const daysDiff = Math.floor(timeDiff / (1000 * 3600 * 24));\r\n      \r\n//       totalDaysOutstanding += daysDiff;\r\n//       orderCount++;\r\n//     });\r\n//   }\r\n  \r\n//   const avgDaysOutstanding = orderCount > 0 ? Math.round(totalDaysOutstanding / orderCount) : 0;\r\n\r\n//   return {\r\n//     totalAR,\r\n//     totalOverdue,\r\n//     customersWithBalance,\r\n//     avgDaysOutstanding\r\n//   };\r\n// };\r\n\r\n// Calculate AR summary\r\nexport const calculateARSummary = (allSalesData) => {\r\n  let totalAR = 0;\r\n  let totalOverdue = 0;\r\n  let totalDaysOutstanding = 0;\r\n  let orderCount = 0;\r\n\r\n  const namedCustomerSet = new Set();\r\n  let customersWithBalance = 0;\r\n\r\n  if (allSalesData && Array.isArray(allSalesData)) {\r\n    allSalesData.forEach(order => {\r\n      // Only consider unpaid or partially paid orders\r\n      if (order['Payment Status'] !== 'Paid') {\r\n        // Clean amount string like \"$50,000.00\" → number\r\n        const amountStr = order.Amount?.toString() || '0';\r\n        const amount = parseFloat(amountStr.replace(/[^0-9.-]+/g,\"\")) || 0;\r\n\r\n        totalAR += amount;\r\n        if (order['Payment Status'] === 'Unpaid') {\r\n          totalOverdue += amount;\r\n        }\r\n\r\n        const customerName = order.Customer?.trim();\r\n        if (customerName && customerName !== 'Guest Customer') {\r\n          if (!namedCustomerSet.has(customerName)) {\r\n            namedCustomerSet.add(customerName);\r\n            customersWithBalance++;\r\n          }\r\n        } else {\r\n          // Count each unpaid guest order separately\r\n          customersWithBalance++;\r\n        }\r\n\r\n        // Parse date safely\r\n        const orderDate = new Date(order.Date);\r\n        if (!isNaN(orderDate)) {\r\n          const today = new Date();\r\n          const daysDiff = Math.floor((today.getTime() - orderDate.getTime()) / (1000 * 3600 * 24));\r\n          totalDaysOutstanding += daysDiff;\r\n          orderCount++;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  const avgDaysOutstanding = orderCount > 0 ? Math.round(totalDaysOutstanding / orderCount) : 0;\r\n\r\n  return {\r\n    totalAR,\r\n    totalOverdue,\r\n    customersWithBalance,\r\n    avgDaysOutstanding\r\n  };\r\n};\r\n\r\n\r\n\r\n// Get aging data\r\nexport const getAgingData = (salesData) => {\r\n  const aging = {\r\n    current: 0,\r\n    days30: 0,\r\n    days60: 0,\r\n    days90: 0,\r\n    over90: 0\r\n  };\r\n\r\n  salesData.forEach(order => {\r\n    if (order.paid) return;\r\n    \r\n    const daysPastDue = order.daysOverdue || 0;\r\n    \r\n    if (daysPastDue <= 0) {\r\n      aging.current += order.total;\r\n    } else if (daysPastDue <= 30) {\r\n      aging.days30 += order.total;\r\n    } else if (daysPastDue <= 60) {\r\n      aging.days60 += order.total;\r\n    } else if (daysPastDue <= 90) {\r\n      aging.days90 += order.total;\r\n    } else {\r\n      aging.over90 += order.total;\r\n    }\r\n  });\r\n\r\n  return aging;\r\n};\r\n\r\n// Filter customers\r\nexport const getFilteredCustomers = (customers, filters) => {\r\n  // First check if we have valid data\r\n  if (!customers || !Array.isArray(customers)) {\r\n    return [];\r\n  }\r\n  \r\n  // Start by filtering ONLY customers WITH names\r\n  let filtered = customers.filter(customer => \r\n    customer && \r\n    customer.name && \r\n    typeof customer.name === 'string' && \r\n    customer.name.trim() !== ''\r\n  );\r\n\r\n  // Now apply the rest of the filters to our name-filtered list\r\n  if (filters && filters.customerType && filters.customerType !== 'all') {\r\n    filtered = filtered.filter(customer => customer.customerType === filters.customerType);\r\n  }\r\n\r\n  if (filters && filters.status && filters.status !== 'all') {\r\n    filtered = filtered.filter(customer => {\r\n      if (filters.status === 'overdue') return customer.overdueAmount > 0;\r\n      if (filters.status === 'current') return customer.totalOwed > 0 && customer.overdueAmount === 0;\r\n      if (filters.status === 'paid_up') return customer.totalOwed === 0;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  if (filters && filters.searchTerm) {\r\n    const term = filters.searchTerm.toLowerCase();\r\n    filtered = filtered.filter(customer =>\r\n      customer.name.toLowerCase().includes(term) ||\r\n      (customer.email && customer.email.toLowerCase().includes(term)) ||\r\n      (customer.id && customer.id.toLowerCase().includes(term))\r\n    );\r\n  }\r\n\r\n  console.log(`Filtered to ${filtered.length} customers with valid names`);\r\n  return filtered;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}